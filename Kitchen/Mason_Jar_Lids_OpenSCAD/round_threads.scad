// Round Thread Library
//
// Generates threads with a circular profile
//
//  David O'Connor https://www.thingiverse.com/lizard00
//
//  This work is under the Creative Commons 3.0 Attribution Unported (CC-BY-3.0) license.
//  (https://creativecommons.org/licenses/by/3.0/)
//
// Parameters: 
// diam          -   Diameter of base cylinder
// thread_diam   -   Diameter of circular thread profile
// pitch         -   Thread pitch
// thread_length -   Length of part
// groove        -   [true] to create groove in base cylinder, otherwise normal thread
// num_starts    -   Number of starts
//
// You can produce left-handed threads by providing a negative pitch value.
// All dimensions are as-is with no calculations for clearance allowance.
// For female threads, you can perform a difference() with your base part and the part generated by this function with 
// [groove] set to true.
//
// 22 November 2018

// round_threads();

//Replace $fs = 0.2*thread_diam with $fs = 2
//Replace $fs = 0.1 with $fs = 2
//Replace $fa = 30 with $fa = 12

module round_threads(diam = 75, thread_diam = 2, pitch = 8, thread_length = 16, groove = false, num_starts = 1) {

if (groove == false) { 
    union() {
        cylinder(r = 0.5*diam, h = thread_length, $fa = 5, $fs = 2 );
        helix(diam = diam, thread_diam = thread_diam, pitch = pitch, thread_length = thread_length, num_starts = num_starts);   
    }
} else {
    difference() {
        cylinder(r = 0.5*diam, h = thread_length, $fa = 5, $fs = 2);
        helix(diam = diam, thread_diam = thread_diam, pitch = pitch, thread_length = thread_length, num_starts = num_starts);   
    }
} 

// Create the helical thread by combining multiple stubby cylinders
module helix(diam, thread_diam , pitch, thread_length, num_starts) {   
    ramp_angle = atan(pitch/(PI*diam));
    total_angle = 360 * thread_length / pitch;
    cylinder_height = thread_diam * 0.5;
    ncyls = total_angle / 360 * PI * diam / cylinder_height * 1.2;
    intersection() {
        cylinder(r = diam, h = thread_length, $fa = 5, $fs = 2); 
        steps_overshoot = floor(0.125*(ncyls/cylinder_height*pitch)); 
        
        union() {
            for (j = [1:num_starts]) { 
                angle_offset = 360 / num_starts * j;
                for (i = [1-steps_overshoot:ncyls+steps_overshoot]) {
                    angle = (total_angle) * (i - 1) / (ncyls-1) + angle_offset ;
                    x = diam/2 * cos(angle);
                    y = diam/2 * sin(angle);
                    z = thread_length * (i - 1) / (ncyls-1);
                
                    translate([x, y, z]) {                       
                        rotate([90, 0, 0]) { 
                            rotate([ramp_angle, angle, 0]) 
                                cylinder(r = 0.5*thread_diam, h = cylinder_height, center=true, $fa=12, $fs = 2);
                        }
                    }
                }
            }
        }
    }
}

}